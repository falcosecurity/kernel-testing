---
# tasks file for bootstrap

- name: "Assert mandatory variables are defined"
  ansible.builtin.assert:
    that:
      - machines is defined
      - ssh_key_path != ""
      - runtime_root != ""
      - run_id != ""

- name: Check if the ~/.ssh directory exists, if not create it
  ansible.builtin.file:
    path: "{{ ssh_key_path }}"
    state: directory
    mode: '0755'

- name: Checking if ssh key exists and if not generate a new one
  community.crypto.openssh_keypair:
    path: "{{ prv_key_path }}"

- name: Create the cached files directory
  ansible.builtin.file:
    path: "{{ cached_files_path }}"
    state: directory
    mode: '0755'

- name: Set run files directory for the current run run_id={{ run_id }}
  ansible.builtin.set_fact:
    bootstrap_run_files_path: "{{ runtime_root }}/{{ run_id }}"

- name: Create the run files directory run_id={{ run_id }}
  ansible.builtin.file:
    path: "{{ bootstrap_run_files_path }}"
    state: directory
    mode: '0755'

- name: Pull kernel and rootfs OCI images
  block:
    - name: Pull kernel OCI images
      community.docker.docker_image:
        name: "{{ item.kernel }}"
        source: pull
        force_source: true
      loop: "{{ machines | union(builders) }}"
      when: item.arch == ansible_facts["architecture"]

    - name: Pull rootfs OCI images
      community.docker.docker_image:
        name: "{{ item.rootfs }}"
        source: pull
        force_source: true
      loop: "{{ machines | union(builders) }}"
      when: item.arch == ansible_facts["architecture"]

- name: Extract vmlinux and initrd from kernel OCI images # noqa: risky-shell-pipe
  vars:
    kernel_basename: "{{ item.kernel | basename | regex_replace(':', '.') }}"
  args:
    creates: "{{ cached_files_path }}/{{ kernel_basename }}.initrd"
  loop: "{{ machines | union(builders) }}"
  when: item.arch == ansible_facts['architecture']
  become: true
  ansible.builtin.shell: |
    # Enable Bash safety only if running under Bash
    [ -n "$BASH_VERSION" ] && eval "set -eo pipefail"

    CID=""
    TMP_DIR=""

    cleanup() {
      [ -n "$CID" ] && docker rm "$CID" >/dev/null 2>&1 || :
      [ -n "$TMP_DIR" ] && rm -rf "$TMP_DIR" || :
    }

    # Trigger cleanup at exit.
    trap cleanup EXIT

    # Create container.
    CID=$(docker create "{{ item.kernel }}" /bin/sh) || exit 1

    # Create a temporary directory.
    TMP_DIR=$(mktemp -d) || exit 1

    # Export and extract vmlinux and initrd while preserving permissions.
    # note: --same-owner and --preserve-permissions requires this task to be run as root.
    docker export "$CID" | tar -x \
      --same-owner \
      --preserve-permissions \
      -C "$TMP_DIR" \
      --strip-components=1 \
      boot/vmlinux \
      boot/initrd

    # Move extracted vmlinux and initrd to destination.
    mv "$TMP_DIR/vmlinux" "{{ cached_files_path }}/{{ kernel_basename }}.vmlinux"
    mv "$TMP_DIR/initrd"  "{{ cached_files_path }}/{{ kernel_basename }}.initrd"

- name: Create raw disk images containing ext4 filesystem from rootfs OCI images # noqa: risky-shell-pipe
  vars:
    rootfs_basename: "{{ item.rootfs | basename | regex_replace(':', '.') }}"
    disk_image: "{{ cached_files_path }}/{{ rootfs_basename }}.ext4"
  args:
    creates: "{{ disk_image }}"
  loop: "{{ machines | union(builders) }}"
  when: item.arch == ansible_facts['architecture']
  become: true
  ansible.builtin.shell: |
    # Enable Bash safety only if running under Bash.
    [ -n "$BASH_VERSION" ] && eval "set -eo pipefail"

    CID=""
    TMP_DIR=""
    LOOPDEV=""

    cleanup() {
      EXIT_STATUS=$?
      [ "$EXIT_STATUS" -ne 0 ] && rm -rf "{{ disk_image }}" || :
      [ -n "$CID" ] && docker rm "$CID" >/dev/null 2>&1 || :
      [ -n "$LOOPDEV" ] && losetup -d "$LOOPDEV" >/dev/null 2>&1 || :
      if [ -n "$TMP_DIR" ]; then
        mountpoint -q "$TMP_DIR" && umount "$TMP_DIR" || :
        rm -rf "$TMP_DIR" || :
      fi
    }

    # Trigger cleanup at exit.
    trap cleanup EXIT

    # Create an initial empty disk image.
    truncate -s 5G "{{ disk_image }}"
    mkfs.ext4 -F "{{ disk_image }}"

    # Create container.
    CID=$(docker create "{{ item.rootfs }}" /bin/sh) || exit 1

    # Create a temporary directory.
    TMP_DIR=$(mktemp -d) || exit 1

    # Attach loop device explicitly
    LOOPDEV=$(losetup -f --show "{{ disk_image }}")

    # Mount disk on a loop device and copy the image content into the disk.
    mount -o loop "{{ disk_image }}" "$TMP_DIR"
    docker export "$CID" | tar -C "$TMP_DIR" -xf -

    # Finalize and check disk integrity.
    sync
    umount "$TMP_DIR"
    losetup -d "$LOOPDEV"
    LOOPDEV=""
    e2fsck -fy "{{ disk_image }}"

- name: Clone raw disk images for the current run run_id={{ run_id }}
  vars:
    rootfs_basename: "{{ item.rootfs | basename | regex_replace(':', '.') }}"
    original_image: "{{ cached_files_path }}/{{ rootfs_basename }}.ext4"
    working_image: "{{ bootstrap_run_files_path }}/{{ rootfs_basename }}.ext4"
  # Create a lightweight CoW clone (if fs supports reflinks) and preserve raw disk sparseness.
  ansible.builtin.command: >
    cp --sparse=always --reflink=auto "{{ original_image }}" "{{ working_image }}"
  args:
    creates: "{{ working_image }}"
  loop: "{{ machines | union(builders) }}"
  when: item.arch == ansible_facts['architecture']
  become: true

- name: Setup ssh inside rootfs ext4 image clones
  vars:
    rootfs_basename: "{{ item.rootfs | basename | regex_replace(':', '.') }}"
    disk_image: "{{ bootstrap_run_files_path }}/{{ rootfs_basename }}.ext4"
  become: true
  block:
    - name: Ensure filesystem is clean before modifying rootfs ext4 image clones
      ansible.builtin.command: e2fsck -fy "{{ disk_image }}"
      changed_when: false
      loop: "{{ machines | union(builders) }}"
      when: item.arch == ansible_facts['architecture']

    - name: Ensure /root/.ssh exists inside rootfs ext4 image clones
      ansible.builtin.shell: |
        e2mkdir -P 700 "{{ disk_image }}:/root/.ssh" || :
      changed_when: false
      loop: "{{ machines | union(builders) }}"
      when: item.arch == ansible_facts['architecture']

    - name: Copy public key inside rootfs ext4 image clones
      ansible.builtin.shell: |
        e2cp -P 600 "{{ pub_key_path }}" "{{ disk_image }}":/root/.ssh/authorized_keys
      changed_when: false
      loop: "{{ machines | union(builders) }}"
      when: item.arch == ansible_facts['architecture']

- name: Run common/tasks/compute_tap_dev_map.yml
  ansible.builtin.import_role:
    name: common
    tasks_from: compute_tap_dev_map

- name: Verify any conflict in tap device map
  ansible.builtin.command: >
    "{{ role_path }}/files/check_net_conflicts.sh" {{ common_tap_dev_map | to_json | quote }}
  changed_when: false

- name: Create and configure tap devices for VMs
  become: true
  block:
    - name: Create tap devices
      vars:
        tap_dev_name: "{{ common_tap_dev_map[item.name].name }}"
      ansible.builtin.command: ip tuntap add dev "{{ tap_dev_name }}" mode tap
      args:
        creates: "/sys/class/net/{{ tap_dev_name }}/ifindex"
      loop: "{{ machines | union(builders) }}"
      when: item.arch == ansible_facts["architecture"]

    - name: Set tap devices up
      vars:
        tap_dev_name: "{{ common_tap_dev_map[item.name].name }}"
      ansible.builtin.command: ip link set "{{ tap_dev_name }}" up
      loop: "{{ machines | union(builders) }}"
      when: item.arch == ansible_facts["architecture"]
      changed_when: false

    - name: Set IP addresses on tap devices
      vars:
        tap_dev_name: "{{ common_tap_dev_map[item.name].name }}"
        ip_addr: "{{ common_tap_dev_map[item.name].host_ip }}/30"
      ansible.builtin.command: ip addr add "{{ ip_addr }}" dev "{{ tap_dev_name }}"
      loop: "{{ machines | union(builders) }}"
      when:
        - item.arch == ansible_facts["architecture"]
        - ip_addr not in lookup('pipe', 'ip -o addr show dev ' ~ tap_dev_name)
      changed_when: true

- name: Start dnsmasq services
  become: true
  block:
    - name: Install dnsmasq-tap@.service
      ansible.builtin.copy:
        src: dnsmasq-tap@.service
        dest: /etc/systemd/system/dnsmasq-tap@.service
        owner: root
        group: root
        mode: "0644"
      notify: Reload systemd

    - name: Execute notified systemd reloading handler
      ansible.builtin.meta: flush_handlers

    - name: Start dnsmasq service on each tap device
      vars:
        tap_dev_name: "{{ common_tap_dev_map[item.name].name }}"
        host_ip: "{{ common_tap_dev_map[item.name].host_ip }}"
        guest_ip: "{{ common_tap_dev_map[item.name].guest_ip }}"
      ansible.builtin.systemd:
        name: "dnsmasq-tap@{{ tap_dev_name }}:{{ host_ip }}:{{ guest_ip }}"
        state: started
      loop: "{{ machines | union(builders) }}"
      when: item.arch == ansible_facts['architecture']

- name: Template the vmconfig.json.j2 configuration file for machine and builders
  vars:
    kernel_basename: "{{ item.kernel | basename | regex_replace(':', '.') }}"
    rootfs_basename: "{{ item.rootfs | basename | regex_replace(':', '.') }}"
    vmlinux_path: "{{ cached_files_path }}/{{ kernel_basename }}.vmlinux"
    initrd_path: "{{ cached_files_path }}/{{ kernel_basename }}.initrd"
    rootfs_disk_path: "{{ bootstrap_run_files_path }}/{{ rootfs_basename }}.ext4"
    tap_dev_name: "{{ common_tap_dev_map[item.name].name }}"
  ansible.builtin.template:
    src: vmconfig.json.j2
    dest: "{{ bootstrap_run_files_path }}/{{ item.name }}.json"
    mode: '0755'
  loop: "{{ machines | union(builders) }}"
  when: item.arch == ansible_facts["architecture"]

- name: Create virtual machines run_id={{ run_id }}
  vars:
    vm_name: "{{ item.name | regex_replace('[.]', '-') }}-{{ run_id }}"
    vm_config_path: "{{ bootstrap_run_files_path }}/{{ item.name }}.json"
    vm_socket_path: "/tmp/{{ run_id }}-{{ item.name }}.sock"
    vm_logs_path: "{{ bootstrap_run_files_path }}/{{ item.name }}.log"
  ansible.builtin.shell: >
    RUST_LOG=debug nohup firecracker \
      --no-seccomp \
      --id "{{ vm_name }}" \
      --config-file "{{ vm_config_path }}" \
      --api-sock "{{ vm_socket_path }}" \
      > "{{ vm_logs_path }}" 2>&1 < /dev/null &
  args:
    executable: /bin/bash
  changed_when: true
  loop: "{{ machines | union(builders) }}"
  when: item.arch == ansible_facts["architecture"]
  become: true

- name: Template the inventory.ini.j2 configuration file to inventory.ini
  ansible.builtin.template:
    src: inventory.ini.j2
    dest: inventory.ini
    mode: '0755'

- name: Refresh inventory to ensure that the new generated one is used
  ansible.builtin.meta: refresh_inventory
