---
# tasks file for bootstrap

- name: "Assert mandatory variables are defined"
  ansible.builtin.assert:
    that:
      - machines is defined
      - ssh_key_path != ""
      - runtime_root != ""
      - run_id != ""

- name: Check if the ~/.ssh directory exists, if not create it
  ansible.builtin.file:
    path: "{{ ssh_key_path }}"
    state: directory
    mode: '0755'

- name: Set files directory for the current run run_id={{ run_id }}
  delegate_to: localhost
  ansible.builtin.set_fact:
    shared_files_path: "./roles/bootstrap/files"
    run_files_path: "{{ runtime_root }}/{{ run_id }}"

- name: Checking if ssh key exists and if not generate a new one
  community.crypto.openssh_keypair:
    path: "{{ prv_key_path }}"

- name: Create the shared files directory
  ansible.builtin.file:
    path: "{{ shared_files_path }}"
    state: directory
    mode: '0755'

- name: Create the run files directory
  ansible.builtin.file:
    path: "{{ run_files_path }}"
    state: directory
    mode: '0755'

- name: Template the ignite-vm.yaml configuration file for machines
  ansible.builtin.template:
    src: ignite-vm.yaml.j2
    dest: "{{ run_files_path }}/{{ item.name }}.yaml"
    mode: '0755'
  loop:
    "{{ machines }}"
  when: item.arch == ansible_facts["architecture"]
  delegate_to: localhost

- name: Template the ignite-vm.yaml configuration file for builders
  ansible.builtin.template:
    src: ignite-vm.yaml.j2
    dest: "{{ run_files_path }}/{{ item.name }}.yaml"
    mode: '0755'
  loop:
    "{{ builders }}"
  when: item.arch == ansible_facts["architecture"]
  delegate_to: localhost

- name: Pull kernel and rootfs OCI images
  block:
    - name: Pull kernel OCI images
      community.docker.docker_image:
        name: "{{ item.kernel }}"
        source: pull
        force_source: true
      loop: "{{ machines | union(builders) }}"
      when: item.arch == ansible_facts["architecture"]

    - name: Pull rootfs OCI images
      community.docker.docker_image:
        name: "{{ item.rootfs }}"
        source: pull
        force_source: true
      loop: "{{ machines | union(builders) }}"
      when: item.arch == ansible_facts["architecture"]

- name: Extract vmlinux and initrd from kernel OCI images # noqa: risky-shell-pipe
  vars:
    kernel_basename: "{{ item.kernel | basename | regex_replace(':', '.') }}"
  args:
    creates: "{{ shared_files_path }}/{{ kernel_basename }}.initrd"
  loop: "{{ machines | union(builders) }}"
  when: item.arch == ansible_facts['architecture']
  become: true
  ansible.builtin.shell: |
    # Enable Bash safety only if running under Bash
    [ -n "$BASH_VERSION" ] && eval "set -eo pipefail"

    CID=""
    TMP_DIR=""

    cleanup() {
      [ -n "$CID" ] && docker rm "$CID" >/dev/null 2>&1 || :
      [ -n "$TMP_DIR" ] && rm -rf "$TMP_DIR" || :
    }

    # Trigger cleanup at exit.
    trap cleanup EXIT

    # Create container.
    CID=$(docker create "{{ item.kernel }}" /bin/sh) || exit 1

    # Create a temporary directory.
    TMP_DIR=$(mktemp -d) || exit 1

    # Export and extract vmlinux and initrd while preserving permissions.
    # note: --same-owner and --preserve-permissions requires this task to be run as root.
    docker export "$CID" | tar -x \
      --same-owner \
      --preserve-permissions \
      -C "$TMP_DIR" \
      --strip-components=1 \
      boot/vmlinux \
      boot/initrd

    # Move extracted vmlinux and initrd to destination.
    mv "$TMP_DIR/vmlinux" "{{ shared_files_path }}/{{ kernel_basename }}.vmlinux"
    mv "$TMP_DIR/initrd"  "{{ shared_files_path }}/{{ kernel_basename }}.initrd"

- name: Create raw disk images containing ext4 filesystem from rootfs OCI images # noqa: risky-shell-pipe
  vars:
    rootfs_basename: "{{ item.rootfs | basename | regex_replace(':', '.') }}"
    disk_image: "{{ shared_files_path }}/{{ rootfs_basename }}.ext4"
  args:
    creates: "{{ disk_image }}"
  loop: "{{ machines | union(builders) }}"
  when: item.arch == ansible_facts['architecture']
  become: true
  ansible.builtin.shell: |
    # Enable Bash safety only if running under Bash.
    [ -n "$BASH_VERSION" ] && eval "set -eo pipefail"
    
    CID=""
    TMP_DIR=""
    LOOPDEV=""
    
    cleanup() {
      EXIT_STATUS=$?
      [ "$EXIT_STATUS" -ne 0 ] && rm -rf "{{ disk_image }}" || :
      [ -n "$CID" ] && docker rm "$CID" >/dev/null 2>&1 || :
      [ -n "$LOOPDEV" ] && losetup -d "$LOOPDEV" >/dev/null 2>&1 || :
      if [ -n "$TMP_DIR" ]; then
        mountpoint -q "$TMP_DIR" && umount "$TMP_DIR" || :
        rm -rf "$TMP_DIR" || :
      fi
    }
    
    # Trigger cleanup at exit.
    trap cleanup EXIT
    
    # Create an initial empty disk image.
    truncate -s 5G "{{ disk_image }}"
    mkfs.ext4 -F "{{ disk_image }}"
    
    # Create container.
    CID=$(docker create "{{ item.rootfs }}" /bin/sh) || exit 1
    
    # Create a temporary directory.
    TMP_DIR=$(mktemp -d) || exit 1
    
    # Attach loop device explicitly
    LOOPDEV=$(losetup -f --show "{{ disk_image }}")

    # Mount disk on a loop device and copy the image content into the disk.
    mount -o loop "{{ disk_image }}" "$TMP_DIR"
    docker export "$CID" | tar -C "$TMP_DIR" -xf -
    
    # Finalize and check disk integrity.
    sync
    umount "$TMP_DIR"
    losetup -d "$LOOPDEV"
    LOOPDEV=""
    e2fsck -fy "{{ disk_image }}"

- name: Create virtual machines run_id={{ run_id }}
  ansible.builtin.command:
    cmd: ignite run --config "{{ run_files_path }}/{{ item.name }}.yaml" --runtime docker
  register: ignite_run
  changed_when: ignite_run.rc == 0
  loop: "{{ machines | union(builders) }}"
  when: item.arch == ansible_facts["architecture"]
  become: true

- name: Wait for the VMs to be running run_id={{ run_id }} # noqa: risky-shell-pipe
  ansible.builtin.shell: |
    if test -v BASH; then set -o pipefail; fi
    ignite ps -f \{\{.ObjectMeta.Name\}\}={{ item.name }}-{{ run_id }},\{\{.Status.Running\}\}=true | wc -l
  register: result
  until: result.stdout | int == 2
  retries: 5
  delay: 10
  loop: "{{ machines | union(builders) }}"
  when: item.arch == ansible_facts["architecture"]
  changed_when: result.stdout | int == 2
  become: true

- name: Get IP of the VMs(machines) and register them in a variable run_id={{ run_id }}
  ansible.builtin.command:
    cmd: ignite ps -f \{\{.ObjectMeta.Name\}\}={{ item.name }}-{{ run_id }},\{\{.Status.Running\}\}=true -t \{\{.Status.Network.IPAddresses\}\}
  register: machine_ips
  failed_when: machine_ips.stdout_lines | length != 1
  changed_when: machine_ips.stdout_lines | length == 1
  loop: "{{ machines }}"
  when: item.arch == ansible_facts["architecture"]
  become: true

- name: Get IP of the VMs(builders) and register them in a variable run_id={{ run_id }}
  ansible.builtin.command:
    cmd: ignite ps -f \{\{.ObjectMeta.Name\}\}={{ item.name }}-{{ run_id }},\{\{.Status.Running\}\}=true -t \{\{.Status.Network.IPAddresses\}\}
  register: builders_ips
  failed_when: builders_ips.stdout_lines | length != 1
  changed_when: builders_ips.stdout_lines | length == 1
  loop: "{{ builders }}"
  when: item.arch == ansible_facts["architecture"]
  become: true

- name: Template the inventory.ini.j2 configuration file to inventory.ini
  ansible.builtin.template:
    src: inventory.ini.j2
    dest: inventory.ini
    mode: '0755'
  delegate_to: localhost

- name: Refresh inventory to ensure that the new generated one is used
  ansible.builtin.meta: refresh_inventory
